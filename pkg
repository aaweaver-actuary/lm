// src/main.rs

fn main() {
    println!("Hello, world!");
}
// src/real_matrix.rs

use ndarray::Array2;

#[derive(Debug, Clone, PartialEq)]
pub struct RealMatrix {
    pub values: Array2<f64>,
}

impl RealMatrix {
    pub fn new(data: Array2<f64>) -> Self {
        RealMatrix { values: data }
    }

    pub fn with_shape(n_rows: usize, n_cols: usize) -> Self {
        RealMatrix {
            values: Array2::<f64>::zeros((n_rows, n_cols)),
        }
    }

    pub fn dot(&self, other: &RealMatrix) -> RealMatrix {
        RealMatrix {
            values: self.values.dot(&other.values),
        }
    }

    pub fn minus(&self, other: &RealMatrix) -> RealMatrix {
        RealMatrix {
            values: &self.values - &other.values,
        }
    }

    pub fn from_vec(data: Vec<f64>, n_rows: usize, n_cols: Option<usize>) -> Self {
        RealMatrix {
            values: Array2::<f64>::from_shape_vec((n_rows, n_cols.unwrap_or(1)), data).unwrap(),
        }
    }

    pub fn as_slice(&self) -> Option<&[f64]> {
        self.values.as_slice()
    }

    pub fn as_slice_mut(&mut self) -> Option<&mut [f64]> {
        self.values.as_slice_mut()
    }

    pub fn shape(&self) -> &[usize; 2] {
        self.values
            .shape()
            .try_into()
            .expect("Shape should have exactly 2 elements")
    }

    pub fn n_rows(&self) -> usize {
        self.values.shape()[0]
    }

    pub fn n_cols(&self) -> usize {
        self.values.shape()[1]
    }

    pub fn is_vec(&self) -> bool {
        self.n_cols() == 1 || self.n_rows() == 1
    }

    pub fn is_empty(&self) -> bool {
        self.values.is_empty()
    }

    pub fn ndim(&self) -> usize {
        self.values.ndim()
    }
}
// src/data.rs

use crate::real_matrix::RealMatrix;

/// A struct representing the data for a linear regression model. This struct always maintains
/// ownership of the data, and is used to pass the data safely between functions. This is
/// the only copy of the data that is passed around, and it is never modified.
#[derive(Debug, Clone, PartialEq)]
pub struct Data {
    pub x: RealMatrix,
    pub y: RealMatrix,
}

impl Data {
    /// Create a new `Data` struct.
    pub fn new(x: RealMatrix, y: RealMatrix) -> Self {
        Data { x, y }
    }

    /// Return a reference to the x matrix.
    pub fn x(&self) -> &RealMatrix {
        &self.x
    }

    /// Return a reference to the y matrix.
    pub fn y(&self) -> &RealMatrix {
        &self.y
    }
}
// src/errors.rs

use thiserror::Error;

#[derive(Debug, Error)]
pub enum FortranLeastSquaresError {
    #[error("Matrix dimensions mismatch: expected ({expected_rows}, {expected_cols}), found ({found_rows}, {found_cols})")]
    DimensionMismatch {
        expected_rows: usize,
        expected_cols: usize,
        found_rows: usize,
        found_cols: usize,
    },
    #[error("Failed to convert RealMatrix to slice")]
    SliceConversionFailure,
    #[error("Null pointer detected during FFI call")]
    NullPointer,
    #[error("Unknown error occurred in Fortran function call")]
    Unknown,
}

#[derive(Debug, Error)]
pub enum LmFitterError {
    #[error("Matrix dimensions mismatch: expected ({expected_rows}, {expected_cols}), found ({found_rows}, {found_cols})")]
    DimensionMismatch {
        expected_rows: usize,
        expected_cols: usize,
        found_rows: usize,
        found_cols: usize,
    },
    #[error("Failed to convert RealMatrix to slice")]
    SliceConversionFailure,
    #[error("Null pointer detected during FFI call")]
    NullPointer,
    #[error("Unknown error occurred in Fortran function call")]
    Unknown,
    #[error("Failed to allocate memory for Fortran arrays")]
    MemoryAllocationFailure,
}
// src/linear_model.rs

use crate::fitters::fit::FitLinearModel;
use crate::{Data, RealMatrix};
use std::cmp::Ordering::{Equal, Greater, Less};

#[derive(Debug, PartialEq)]
pub enum LinearModel<'a> {
    Fitted(FittedLinearModel<'a>),
    Unfitted(UnfittedLinearModel<'a>),
}

impl<'a> PartialOrd for LinearModel<'a> {
    /// Compare two `LinearModel` instances. This is mainly useful for testing purposes. Fitted > Unfitted.
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        match (self, other) {
            (LinearModel::Fitted(_), LinearModel::Unfitted(_)) => Some(Greater),
            (LinearModel::Unfitted(_), LinearModel::Fitted(_)) => Some(Less),
            (LinearModel::Fitted(_), LinearModel::Fitted(_)) => Some(Equal),
            (LinearModel::Unfitted(_), LinearModel::Unfitted(_)) => Some(Equal),
        }
    }
}

impl<'a> LinearModel<'a> {
    pub fn new(data: &'a Data) -> Self {
        LinearModel::Unfitted(UnfittedLinearModel::new(data))
    }

    pub fn update_coefficients(&mut self, coefficients: RealMatrix) {
        match self {
            LinearModel::Fitted(fitted) => fitted.update_coefficients(coefficients),
            LinearModel::Unfitted(_) => (),
        }
    }

    pub fn data(&self) -> &Data {
        match self {
            LinearModel::Fitted(fitted) => fitted.data,
            LinearModel::Unfitted(unfitted) => unfitted.data,
        }
    }

    pub fn x(&self) -> &RealMatrix {
        match self {
            LinearModel::Fitted(fitted) => &fitted.data.x(),
            LinearModel::Unfitted(unfitted) => &unfitted.data.x(),
        }
    }

    pub fn y(&self) -> &RealMatrix {
        match self {
            LinearModel::Fitted(fitted) => &fitted.data.y(),
            LinearModel::Unfitted(unfitted) => &unfitted.data.y(),
        }
    }

    pub fn fit(&mut self, fitter: &impl FitLinearModel) {
        match self {
            // If already fitted, re-fit the model.
            LinearModel::Fitted(_) => {
                self.update_coefficients(fitter.fit().unwrap());
            }

            // If unfitted, fit the model and update the enum variant.
            LinearModel::Unfitted(unfitted_model) => {
                *self = LinearModel::Fitted(FittedLinearModel {
                    data: unfitted_model.data,
                    coefficients: fitter.fit().unwrap(),
                });
            }
        }
    }

    pub fn coefficients(&self) -> Option<&RealMatrix> {
        match self {
            LinearModel::Fitted(fitted) => Some(&fitted.coefficients),
            LinearModel::Unfitted(_) => None,
        }
    }

    pub fn residuals(&self) -> Option<RealMatrix> {
        match self {
            LinearModel::Fitted(fitted) => Some(fitted.residuals()),
            LinearModel::Unfitted(_) => None,
        }
    }

    pub fn predict(&self, x: Option<&RealMatrix>) -> Option<RealMatrix> {
        match self {
            LinearModel::Fitted(fitted) => Some(fitted.predict(x)),
            LinearModel::Unfitted(_) => None,
        }
    }
}

#[derive(Debug, PartialEq)]
pub struct FittedLinearModel<'a> {
    pub data: &'a Data,
    pub coefficients: RealMatrix,
}

impl<'a> FittedLinearModel<'a> {
    pub fn new(data: &'a Data, coefficients: RealMatrix) -> Self {
        FittedLinearModel { data, coefficients }
    }

    pub fn update_coefficients(&mut self, coefficients: RealMatrix) {
        self.coefficients = coefficients;
    }

    pub fn predict(&self, x: Option<&RealMatrix>) -> RealMatrix {
        match x {
            // If x is provided, use it to make predictions.
            Some(x) => x.dot(&self.coefficients),

            // If x is not provided, use the data's x matrix to make predictions.
            None => self.data.x().dot(&self.coefficients),
        }
    }

    pub fn residuals(&self) -> RealMatrix {
        self.data.y().minus(&self.predict(Some(self.data.x())))
    }
}

#[derive(Debug, PartialEq)]
pub struct UnfittedLinearModel<'a> {
    pub data: &'a Data,
}

impl<'a> UnfittedLinearModel<'a> {
    pub fn new(data: &'a Data) -> Self {
        UnfittedLinearModel { data }
    }
}
// src/lib.rs

pub mod data;
pub mod dqrls;
pub mod errors;
pub mod fitters;
pub mod linear_model;
pub mod real_matrix;

pub use data::Data;
pub use real_matrix::RealMatrix;

pub fn check_that_x_is_a_2d_matrix(x: &RealMatrix) {
    assert_eq!(x.ndim(), 2);
}

pub fn extract_dimensions_of_a_2d_matrix(x: &RealMatrix) -> (usize, usize) {
    (x.shape()[0], x.shape()[1])
}

pub fn check_that_x_and_y_have_the_same_number_of_rows(x: &RealMatrix, y: &RealMatrix) {
    assert_eq!(x.shape()[0], y.shape()[0]);
}

pub fn check_that_2d_matrix_x_is_numeric(x: &RealMatrix) {
    assert!(x.values.iter().all(|&v| v.is_finite()));
}

pub fn initialize_qr_decomposition(_q: RealMatrix, _r: RealMatrix) {
    todo!()
}

pub fn initialize_coefficients_vector(n: usize) -> RealMatrix {
    RealMatrix::with_shape(n, 1)
}

pub fn initialize_residuals_vector(n: usize) -> RealMatrix {
    RealMatrix::with_shape(n, 1)
}

pub fn initialize_effects_vector(n: usize) -> RealMatrix {
    RealMatrix::with_shape(n, 1)
}

pub fn initialize_pivots_vector(n: usize) -> RealMatrix {
    RealMatrix::with_shape(n, 1)
}

pub fn initialize_qr_auxiliary_matrix(n: usize) {
    let q = RealMatrix::with_shape(n, n);
    let r = RealMatrix::with_shape(n, n);
    initialize_qr_decomposition(q, r)
}
// src/fitters/mod.rs

pub mod fit;
pub mod qr_decomposition_fitter;
// src/fitters/qr_decomposition_fitter.rs

use super::fit::FitLinearModel;
use crate::errors::{FortranLeastSquaresError, LmFitterError};
use crate::linear_model::LinearModel;
use crate::{Data, RealMatrix};
use derive_builder::Builder;
use libc::c_int;

#[derive(Debug)]
pub struct QrDecompositionFitter<'a> {
    data: &'a Data,
    lm: LinearModel<'a>,
}

impl<'a> QrDecompositionFitter<'a> {
    pub fn new(data: &'a Data) -> Self {
        QrDecompositionFitter {
            data,
            lm: LinearModel::new(data),
        }
    }

    pub fn x(&self) -> &RealMatrix {
        &self.data.x
    }

    pub fn y(&self) -> &RealMatrix {
        &self.data.y
    }
}

impl<'a> FitLinearModel for QrDecompositionFitter<'a> {
    /// Use the QR decomposition method to fit the linear model to the data.
    /// Calls the FFI function that wraps the LINPACK dqrls subroutine below.
    /// The function signature is:
    /// ```fortran
    /// subroutine dqrls(x,n,p,y,ny,tol,b,rsd,qty,k,jpvt,qraux,work)
    /// ```g
    ///
    /// # Returns
    ///
    fn fit(&self) -> Result<RealMatrix, LmFitterError> {
        let mut fitter = FortranLeastSquaresQrDecomposition::new(self.data, None);
        let result = fitter.dqrls();
        match result {
            Ok(fitted) => Ok(fitted.beta),
            Err(_e) => Err(LmFitterError::Unknown),
        }
    }

    fn x(&self) -> &RealMatrix {
        self.data.x()
    }

    fn y(&self) -> &RealMatrix {
        self.data.y()
    }
}

/*
This is a Rust implementation of the LINPACK dqrls subroutine. The original
Fortran code is in this file:
    * dqrls.f (/src/fortran/dqrls.f)[/src/bin/libdqrls.so]

Definition of the dqrls subroutine:
    * subroutine dqrls(x,n,p,y,ny,tol,b,rsd,qty,k,jpvt,qraux,work)
*/

extern "C" {
    /// This is the FFI function that calls the LINPACK dqrls subroutine.
    /// The function signature is:
    /// ```fortran
    /// subroutine dqrls(x,n,p,y,ny,tol,b,rsd,qty,k,jpvt,qraux,work)
    /// ```
    ///
    /// # Parameters
    /// * `x` is a matrix of real numbers representing the independent variables.
    /// * `n` is the number of rows in the matrix `x`.
    /// * `p` is the number of columns in the matrix `x`.
    /// * `y` is a matrix of real numbers representing the dependent variables.
    /// * `ny` is the number of columns in the matrix `y`.
    /// * `tol` is the tolerance for determining the rank of the matrix.
    /// * `b` is a matrix of real numbers representing the coefficients in a linear model.
    /// * `rsd` is a matrix of real numbers representing the residuals.
    /// * `qty` is a matrix of real numbers representing the Q-transposed times Y matrix.
    /// * `k` is the number of columns used in the solution.
    /// * `jpvt` is the pivot vector for the matrix `x`.
    /// * `qraux` is auxiliary information for the QR decomposition.
    /// * `work` is a work array.
    fn f_dqrls(
        x: *mut f64,      // Matrix X (modified in place)
        n: *const c_int,  // Number of rows in X
        p: *const c_int,  // Number of columns in X
        y: *const f64,    // Right-hand side matrix Y
        ny: *const c_int, // Number of columns in Y
        tol: *const f64,  // Tolerance for determining rank
        b: *mut f64,      // Solution matrix B
        rsd: *mut f64,    // Residual matrix
        qty: *mut f64,    // Q-transposed times Y matrix
        k: *mut c_int,    // Number of columns used in solution
        jpvt: *mut c_int, // Pivot vector for X
        qraux: *mut f64,  // Auxiliary information for QR decomposition
        work: *mut f64,   // Work array
    );
}

#[derive(Debug, Builder)]
pub struct FortranLeastSquaresReturn {
    /// `beta` is a matrix of real numbers representing the coefficients
    /// in a linear model. It is used to store the estimated parameters
    /// after fitting the model to the data.
    pub beta: RealMatrix,
    pub residuals: RealMatrix,
    pub q_transposed_times_y: RealMatrix,
    pub qr_decomp_auxiliary_information: RealMatrix,
}

impl FortranLeastSquaresReturn {
    pub fn builder() -> FortranLeastSquaresReturnBuilder {
        FortranLeastSquaresReturnBuilder::default()
    }
}

type ColumnPivot = Vec<c_int>;
type AuxiliaryInformation = Vec<f64>;
type Work = Vec<f64>;

#[derive(Debug, Builder)]
pub struct FortranLeastSquaresQrDecomposition<'a> {
    pub data: &'a Data,
    pub tol: Option<f64>,
}

impl<'a> FortranLeastSquaresQrDecomposition<'a> {
    pub fn new(data: &'a Data, tol: Option<f64>) -> Self {
        Self { data, tol }
    }

    pub fn dqrls(&mut self) -> Result<FortranLeastSquaresReturn, FortranLeastSquaresError> {
        let (n_rows, n_cols, n_cols_y) = self.get_dimensions();
        let (mut coefficients, mut residuals, mut qty) = self.allocate_solution_arrays();
        let (mut jpvt, mut qraux, mut work) = self.allocate_auxiliary_arrays();

        // Initialize number of columns used (k)
        let mut n_columns_used: i32 = 0 as c_int;

        unsafe {
            f_dqrls(
                self.data.x.as_slice().unwrap().as_ptr() as *mut f64,
                &n_rows,
                &n_cols,
                self.data.y.as_slice().unwrap().as_ptr(),
                &n_cols_y,
                &self.tol(),
                coefficients.as_slice_mut().unwrap().as_mut_ptr(),
                residuals.as_slice_mut().unwrap().as_mut_ptr(),
                qty.as_slice_mut().unwrap().as_mut_ptr(),
                &mut n_columns_used,
                jpvt.as_mut_ptr(),
                qraux.as_mut_ptr(),
                work.as_mut_ptr(),
            );
        }

        // Return the computed matrices
        Ok(FortranLeastSquaresReturn::builder()
            .beta(coefficients)
            .residuals(residuals)
            .q_transposed_times_y(qty)
            .qr_decomp_auxiliary_information(RealMatrix::from_vec(qraux, n_cols as usize, None))
            .build()
            .unwrap())
    }

    /// Get the dimensions of the input matrices
    ///
    /// # Example
    /// ```
    /// use lm::dqrls::{FortranLeastSquaresQrDecomposition, LinearSystem, RealMatrix};
    /// use ndarray::Array2;
    ///
    /// let x = RealMatrix::with_shape(3, 2);
    /// let y = RealMatrix::with_shape(3, 1);
    /// let dqrls = FortranLeastSquaresQrDecomposition::new(x, y, None);
    /// assert_eq!(dqrls.get_dimensions(), (3, 2, 1));
    /// assert_eq!(dqrls.get_dimensions(), (x.n_rows() as i32, x.n_cols() as i32, y.n_cols() as i32));
    /// ```
    pub fn get_dimensions(&self) -> (c_int, c_int, c_int) {
        (
            self.data.x().n_rows() as c_int,
            self.data.x().n_cols() as c_int,
            self.data.y().n_cols() as c_int,
        )
    }

    /// Allocate solution arrays for the QR decomposition
    ///
    /// # Example
    /// ```
    /// use lm::dqrls::{FortranLeastSquaresQrDecomposition, RealMatrix};
    /// use ndarray::Array2;
    ///
    /// let x = RealMatrix::with_shape(3, 2);
    /// let y = RealMatrix::with_shape(3, 1);
    /// let dqrls = FortranLeastSquaresQrDecomposition::new(x, y, None);
    /// let (b, rsd, qty) = dqrls.allocate_solution_arrays();
    /// assert_eq!(b, RealMatrix::with_shape(3, 1));
    /// assert_eq!(rsd, RealMatrix::with_shape(3, 1));
    /// assert_eq!(qty, RealMatrix::with_shape(3, 1));
    /// ```
    pub fn allocate_solution_arrays(&self) -> (RealMatrix, RealMatrix, RealMatrix) {
        (
            RealMatrix::with_shape(self.data.x().n_rows(), self.data.y().n_cols()), // Solution vector
            RealMatrix::with_shape(self.data.x().n_rows(), self.data.y().n_cols()), // Residuals
            RealMatrix::with_shape(self.data.x().n_rows(), self.data.y().n_cols()), // Q-transposed times Y
        )
    }

    /// Allocate auxiliary arrays for the QR decomposition
    ///
    /// # Example
    /// ```
    /// use lm::dqrls::{FortranLeastSquaresQrDecomposition, RealMatrix};
    ///
    /// let x = RealMatrix::with_shape(3, 2);
    /// let y = RealMatrix::with_shape(3, 1);
    /// let dqrls = FortranLeastSquaresQrDecomposition::new(x, y, None);
    /// let (jpvt, qraux, work) = dqrls.allocate_auxiliary_arrays();
    /// assert_eq!(jpvt, vec![0, 0]);
    /// assert_eq!(qraux, vec![0.0, 0.0]);
    /// assert_eq!(work, vec![0.0, 0.0, 0.0, 0.0]);
    /// ```
    pub fn allocate_auxiliary_arrays(&self) -> (ColumnPivot, AuxiliaryInformation, Work) {
        (
            vec![0 as c_int; self.data.x().n_cols()], // Column pivot vector
            vec![0.0; self.data.x().n_cols()],        // Auxiliary information
            vec![0.0; self.data.x().n_cols()],        // Work array
        )
    }
    /// Get the tolerance for determining the rank of the matrix
    ///
    /// # Example
    /// ```
    /// use lm::dqrls::{FortranLeastSquaresQrDecomposition, RealMatrix};
    ///
    /// let x = RealMatrix::with_shape(3, 2);
    /// let y = RealMatrix::with_shape(3, 1);
    /// let dqrls = FortranLeastSquaresQrDecomposition::new(x, y, Some(1e-10));
    /// assert_eq!(dqrls.tol(), 1e-10);
    /// ```
    fn tol(&self) -> f64 {
        self.tol.unwrap_or(1e-10)
    }
}
// src/fitters/fit.rs

use super::qr_decomposition_fitter::QrDecompositionFitter;
use crate::errors::LmFitterError;
use crate::RealMatrix;

/// A trait for fitting a linear regression model to a dataset.
///
/// This trait is implemented for the `LinearSystemSolver` enum, which allows the user to choose
/// the desired strategy for solving the linear system. Each strategy is implemented in a separate
/// module, and must also implement the `SolveLinearRegression` trait.
pub trait FitLinearModel {
    /// Fit the linear regression model to the data.
    fn fit(&self) -> Result<RealMatrix, LmFitterError>;

    /// Get the x matrix.
    fn x(&self) -> &RealMatrix;

    /// Get the y matrix.
    fn y(&self) -> &RealMatrix;
}

/// An enum representing the available strategies for fitting a linear model to a dataset.
#[derive(Debug)]
pub enum LinearModelFitter<'a> {
    /// Fit the linear model using the QR decomposition method.
    QrDecomposition(QrDecompositionFitter<'a>),
}

impl<'a> FitLinearModel for LinearModelFitter<'a> {
    fn fit(&self) -> Result<RealMatrix, LmFitterError> {
        match self {
            LinearModelFitter::QrDecomposition(fitter) => fitter.fit(),
        }
    }

    fn x(&self) -> &RealMatrix {
        match self {
            LinearModelFitter::QrDecomposition(fitter) => fitter.x(),
        }
    }

    fn y(&self) -> &RealMatrix {
        match self {
            LinearModelFitter::QrDecomposition(fitter) => fitter.y(),
        }
    }
}
